{"ast":null,"code":"// Data Collection and Integration Service\nimport { saveAssessmentResult, saveInterventionUsage, saveProgressEntry } from '../components/firestoreHelpers';\nimport authService from './AuthService';\nclass DataCollectionService {\n  constructor() {\n    this.dataStore = {\n      assessments: [],\n      biometrics: [],\n      interventions: [],\n      userProfile: {},\n      preferences: {}\n    };\n    this.initialized = false;\n  }\n\n  // Initialize the service\n  async initialize() {\n    try {\n      // Initialize auth service first\n      authService.initialize();\n\n      // Load existing data from localStorage\n      const storedData = localStorage.getItem('echoMentalHealthData');\n      if (storedData) {\n        this.dataStore = {\n          ...this.dataStore,\n          ...JSON.parse(storedData)\n        };\n      }\n\n      // Initialize wearable connections\n      await this.initializeWearableConnections();\n      this.initialized = true;\n      console.log('✅ Data Collection Service initialized');\n    } catch (error) {\n      console.error('❌ Failed to initialize Data Collection Service:', error);\n    }\n  }\n\n  // Save assessment data\n  saveAssessment(assessmentData) {\n    const assessment = {\n      id: Date.now().toString(),\n      timestamp: new Date().toISOString(),\n      type: 'mental_health_assessment',\n      data: assessmentData,\n      source: 'app_questionnaire'\n    };\n    this.dataStore.assessments.push(assessment);\n    this.persistData();\n\n    // Trigger analytics update\n    this.analyzePatterns();\n    return assessment.id;\n  }\n\n  // Save biometric data\n  saveBiometricData(data, source = 'manual') {\n    const biometricEntry = {\n      id: Date.now().toString(),\n      timestamp: new Date().toISOString(),\n      data: data,\n      source: source // 'camera', 'wearable', 'manual', etc.\n    };\n    this.dataStore.biometrics.push(biometricEntry);\n    this.persistData();\n    return biometricEntry.id;\n  }\n\n  // Save intervention usage\n  saveInterventionUsage(interventionType, duration, effectiveness) {\n    const intervention = {\n      id: Date.now().toString(),\n      timestamp: new Date().toISOString(),\n      type: interventionType,\n      duration: duration,\n      effectiveness: effectiveness,\n      // 1-5 scale\n      context: this.getCurrentContext()\n    };\n    this.dataStore.interventions.push(intervention);\n    this.persistData();\n    return intervention.id;\n  }\n\n  // Camera-based emotion detection\n  async analyzeFacialExpressions(videoElement) {\n    try {\n      // This would integrate with TensorFlow.js or similar\n      // For now, returning mock data\n      const mockEmotionData = {\n        emotions: {\n          happiness: Math.random() * 0.4,\n          sadness: Math.random() * 0.3,\n          anxiety: Math.random() * 0.4,\n          stress: Math.random() * 0.3,\n          neutral: Math.random() * 0.5,\n          anger: Math.random() * 0.2,\n          fear: Math.random() * 0.2\n        },\n        microExpressions: {\n          eyeMovement: Math.random() * 100,\n          blinkRate: Math.random() * 20 + 15,\n          facialTension: Math.random() * 100,\n          jawTension: Math.random() * 100\n        },\n        faceMetrics: {\n          symmetry: Math.random() * 100,\n          skinTone: Math.random() * 100,\n          eyeBags: Math.random() * 100\n        },\n        confidence: 0.75 + Math.random() * 0.2,\n        processingTime: Math.random() * 500 + 200\n      };\n      this.saveBiometricData(mockEmotionData, 'camera');\n      return mockEmotionData;\n    } catch (error) {\n      console.error('Facial expression analysis failed:', error);\n      return null;\n    }\n  }\n\n  // Heart rate detection through camera\n  async detectHeartRateFromCamera(videoElement) {\n    try {\n      // This would use photoplethysmography (PPG) through camera\n      // Analyzing color changes in face/fingertip\n      const mockHeartRateData = {\n        heartRate: Math.floor(Math.random() * 40) + 60,\n        // 60-100 bpm\n        heartRateVariability: Math.random() * 50 + 25,\n        confidence: 0.7 + Math.random() * 0.25,\n        signalQuality: Math.random() * 100,\n        timestamp: new Date().toISOString()\n      };\n      this.saveBiometricData(mockHeartRateData, 'camera_ppg');\n      return mockHeartRateData;\n    } catch (error) {\n      console.error('Heart rate detection failed:', error);\n      return null;\n    }\n  }\n\n  // Initialize wearable device connections\n  async initializeWearableConnections() {\n    try {\n      // Check for Web Bluetooth support\n      if ('bluetooth' in navigator) {\n        console.log('Bluetooth API available');\n        // Future implementation for fitness trackers, smartwatches\n      }\n\n      // Check for Web USB support\n      if ('usb' in navigator) {\n        console.log('USB API available');\n        // Future implementation for USB-connected devices\n      }\n\n      // Initialize mock wearable data\n      this.startMockWearableDataCollection();\n    } catch (error) {\n      console.error('Wearable initialization error:', error);\n    }\n  }\n\n  // Mock wearable data collection (for demonstration)\n  startMockWearableDataCollection() {\n    // Simulate periodic data from a fitness tracker\n    setInterval(() => {\n      if (Math.random() > 0.8) {\n        // 20% chance every interval\n        const wearableData = {\n          heartRate: Math.floor(Math.random() * 40) + 60,\n          steps: Math.floor(Math.random() * 1000),\n          sleepQuality: Math.random() * 100,\n          stressLevel: Math.random() * 100,\n          skinTemperature: 36 + Math.random() * 2,\n          oxygenSaturation: 95 + Math.random() * 5\n        };\n        this.saveBiometricData(wearableData, 'wearable_mock');\n      }\n    }, 30000); // Every 30 seconds\n  }\n\n  // Analyze patterns in collected data\n  analyzePatterns() {\n    try {\n      const recentData = this.getRecentData(7); // Last 7 days\n\n      const patterns = {\n        moodTrends: this.analyzeMoodTrends(recentData.assessments),\n        biometricPatterns: this.analyzeBiometricPatterns(recentData.biometrics),\n        interventionEffectiveness: this.analyzeInterventionEffectiveness(recentData.interventions),\n        riskFactors: this.identifyRiskFactors(recentData),\n        recommendations: this.generateRecommendations(recentData)\n      };\n\n      // Store analysis results\n      this.dataStore.latestAnalysis = {\n        timestamp: new Date().toISOString(),\n        patterns: patterns\n      };\n      this.persistData();\n      return patterns;\n    } catch (error) {\n      console.error('Pattern analysis failed:', error);\n      return null;\n    }\n  }\n\n  // Get recent data within specified days\n  getRecentData(days) {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    return {\n      assessments: this.dataStore.assessments.filter(item => new Date(item.timestamp) > cutoffDate),\n      biometrics: this.dataStore.biometrics.filter(item => new Date(item.timestamp) > cutoffDate),\n      interventions: this.dataStore.interventions.filter(item => new Date(item.timestamp) > cutoffDate)\n    };\n  }\n\n  // Analyze mood trends\n  analyzeMoodTrends(assessments) {\n    if (assessments.length < 2) return {\n      trend: 'insufficient_data'\n    };\n    const moodScores = assessments.map(a => a.data.overallScore).filter(score => score !== undefined);\n    if (moodScores.length < 2) return {\n      trend: 'insufficient_data'\n    };\n    const firstHalf = moodScores.slice(0, Math.ceil(moodScores.length / 2));\n    const secondHalf = moodScores.slice(Math.floor(moodScores.length / 2));\n    const firstAvg = firstHalf.reduce((sum, score) => sum + score, 0) / firstHalf.length;\n    const secondAvg = secondHalf.reduce((sum, score) => sum + score, 0) / secondHalf.length;\n    const difference = secondAvg - firstAvg;\n    return {\n      trend: difference > 0.2 ? 'improving' : difference < -0.2 ? 'declining' : 'stable',\n      change: difference,\n      currentAverage: secondAvg,\n      confidence: Math.min(moodScores.length / 10, 1) // More data = higher confidence\n    };\n  }\n\n  // Analyze biometric patterns\n  analyzeBiometricPatterns(biometrics) {\n    const heartRateData = biometrics.filter(b => b.data.heartRate).map(b => b.data.heartRate);\n    const stressData = biometrics.filter(b => b.data.stressLevel).map(b => b.data.stressLevel);\n    return {\n      heartRate: {\n        average: heartRateData.length > 0 ? heartRateData.reduce((sum, hr) => sum + hr, 0) / heartRateData.length : null,\n        trend: this.calculateTrend(heartRateData),\n        variability: this.calculateVariability(heartRateData)\n      },\n      stress: {\n        average: stressData.length > 0 ? stressData.reduce((sum, s) => sum + s, 0) / stressData.length : null,\n        trend: this.calculateTrend(stressData)\n      }\n    };\n  }\n\n  // Analyze intervention effectiveness\n  analyzeInterventionEffectiveness(interventions) {\n    const effectiveness = {};\n    interventions.forEach(intervention => {\n      if (!effectiveness[intervention.type]) {\n        effectiveness[intervention.type] = {\n          uses: 0,\n          totalEffectiveness: 0,\n          avgDuration: 0,\n          totalDuration: 0\n        };\n      }\n      effectiveness[intervention.type].uses++;\n      effectiveness[intervention.type].totalEffectiveness += intervention.effectiveness || 3;\n      effectiveness[intervention.type].totalDuration += intervention.duration || 300;\n    });\n\n    // Calculate averages\n    Object.keys(effectiveness).forEach(type => {\n      const data = effectiveness[type];\n      data.avgEffectiveness = data.totalEffectiveness / data.uses;\n      data.avgDuration = data.totalDuration / data.uses;\n    });\n    return effectiveness;\n  }\n\n  // Identify risk factors\n  identifyRiskFactors(data) {\n    const risks = [];\n\n    // Check mood trends\n    const moodTrend = this.analyzeMoodTrends(data.assessments);\n    if (moodTrend.trend === 'declining') {\n      risks.push({\n        type: 'declining_mood',\n        severity: Math.abs(moodTrend.change) > 0.5 ? 'high' : 'medium',\n        description: 'Estado de ánimo en declive'\n      });\n    }\n\n    // Check biometric patterns\n    const biometrics = this.analyzeBiometricPatterns(data.biometrics);\n    if (biometrics.heartRate.average > 90) {\n      risks.push({\n        type: 'elevated_heart_rate',\n        severity: 'medium',\n        description: 'Frecuencia cardíaca elevada promedio'\n      });\n    }\n\n    // Check intervention usage\n    if (data.interventions.length < 3) {\n      risks.push({\n        type: 'low_engagement',\n        severity: 'low',\n        description: 'Bajo uso de técnicas de calma'\n      });\n    }\n    return risks;\n  }\n\n  // Generate personalized recommendations\n  generateRecommendations(data) {\n    const recommendations = [];\n\n    // Based on mood trends\n    const moodTrend = this.analyzeMoodTrends(data.assessments);\n    if (moodTrend.trend === 'declining') {\n      recommendations.push({\n        type: 'intervention',\n        priority: 'high',\n        message: 'Considera aumentar el uso de técnicas de respiración y afirmaciones positivas'\n      });\n    }\n\n    // Based on intervention effectiveness\n    const effectiveness = this.analyzeInterventionEffectiveness(data.interventions);\n    const mostEffective = Object.entries(effectiveness).sort((a, b) => b[1].avgEffectiveness - a[1].avgEffectiveness)[0];\n    if (mostEffective) {\n      recommendations.push({\n        type: 'technique',\n        priority: 'medium',\n        message: `La técnica \"${mostEffective[0]}\" ha sido más efectiva para ti`\n      });\n    }\n\n    // General wellness recommendations\n    recommendations.push({\n      type: 'general',\n      priority: 'low',\n      message: 'Mantén un horario regular para tus evaluaciones de bienestar'\n    });\n    return recommendations;\n  }\n\n  // Utility functions\n  calculateTrend(values) {\n    if (values.length < 2) return 'insufficient_data';\n    const firstHalf = values.slice(0, Math.ceil(values.length / 2));\n    const secondHalf = values.slice(Math.floor(values.length / 2));\n    const firstAvg = firstHalf.reduce((sum, val) => sum + val, 0) / firstHalf.length;\n    const secondAvg = secondHalf.reduce((sum, val) => sum + val, 0) / secondHalf.length;\n    const difference = secondAvg - firstAvg;\n    return difference > 5 ? 'increasing' : difference < -5 ? 'decreasing' : 'stable';\n  }\n  calculateVariability(values) {\n    if (values.length < 2) return 0;\n    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;\n    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;\n    return Math.sqrt(variance);\n  }\n  getCurrentContext() {\n    return {\n      timeOfDay: new Date().getHours(),\n      dayOfWeek: new Date().getDay(),\n      location: 'unknown',\n      // Would integrate with geolocation\n      weather: 'unknown' // Would integrate with weather API\n    };\n  }\n\n  // Data persistence\n  persistData() {\n    try {\n      localStorage.setItem('echoMentalHealthData', JSON.stringify(this.dataStore));\n    } catch (error) {\n      console.error('Failed to persist data:', error);\n    }\n  }\n\n  // Export data for analysis or backup\n  exportData() {\n    return {\n      exportDate: new Date().toISOString(),\n      version: '1.0',\n      data: this.dataStore\n    };\n  }\n\n  // Clear all data (with confirmation)\n  clearAllData() {\n    this.dataStore = {\n      assessments: [],\n      biometrics: [],\n      interventions: [],\n      userProfile: {},\n      preferences: {}\n    };\n    localStorage.removeItem('echoMentalHealthData');\n  }\n\n  // Get comprehensive analytics\n  getAnalytics(timeRange = 30) {\n    const recentData = this.getRecentData(timeRange);\n    return {\n      summary: {\n        totalAssessments: recentData.assessments.length,\n        totalInterventions: recentData.interventions.length,\n        averageMoodScore: this.calculateAverageScore(recentData.assessments),\n        timeRange: timeRange\n      },\n      patterns: this.analyzePatterns(),\n      riskFactors: this.identifyRiskFactors(recentData),\n      recommendations: this.generateRecommendations(recentData)\n    };\n  }\n  calculateAverageScore(assessments) {\n    if (assessments.length === 0) return null;\n    const scores = assessments.map(a => a.data.overallScore).filter(score => score !== undefined);\n    return scores.length > 0 ? scores.reduce((sum, score) => sum + score, 0) / scores.length : null;\n  }\n}\n\n// Create singleton instance\nconst dataCollectionService = new DataCollectionService();\nexport default dataCollectionService;","map":{"version":3,"names":["saveAssessmentResult","saveInterventionUsage","saveProgressEntry","authService","DataCollectionService","constructor","dataStore","assessments","biometrics","interventions","userProfile","preferences","initialized","initialize","storedData","localStorage","getItem","JSON","parse","initializeWearableConnections","console","log","error","saveAssessment","assessmentData","assessment","id","Date","now","toString","timestamp","toISOString","type","data","source","push","persistData","analyzePatterns","saveBiometricData","biometricEntry","interventionType","duration","effectiveness","intervention","context","getCurrentContext","analyzeFacialExpressions","videoElement","mockEmotionData","emotions","happiness","Math","random","sadness","anxiety","stress","neutral","anger","fear","microExpressions","eyeMovement","blinkRate","facialTension","jawTension","faceMetrics","symmetry","skinTone","eyeBags","confidence","processingTime","detectHeartRateFromCamera","mockHeartRateData","heartRate","floor","heartRateVariability","signalQuality","navigator","startMockWearableDataCollection","setInterval","wearableData","steps","sleepQuality","stressLevel","skinTemperature","oxygenSaturation","recentData","getRecentData","patterns","moodTrends","analyzeMoodTrends","biometricPatterns","analyzeBiometricPatterns","interventionEffectiveness","analyzeInterventionEffectiveness","riskFactors","identifyRiskFactors","recommendations","generateRecommendations","latestAnalysis","days","cutoffDate","setDate","getDate","filter","item","length","trend","moodScores","map","a","overallScore","score","undefined","firstHalf","slice","ceil","secondHalf","firstAvg","reduce","sum","secondAvg","difference","change","currentAverage","min","heartRateData","b","stressData","average","hr","calculateTrend","variability","calculateVariability","s","forEach","uses","totalEffectiveness","avgDuration","totalDuration","Object","keys","avgEffectiveness","risks","moodTrend","severity","abs","description","priority","message","mostEffective","entries","sort","values","val","mean","variance","pow","sqrt","timeOfDay","getHours","dayOfWeek","getDay","location","weather","setItem","stringify","exportData","exportDate","version","clearAllData","removeItem","getAnalytics","timeRange","summary","totalAssessments","totalInterventions","averageMoodScore","calculateAverageScore","scores","dataCollectionService"],"sources":["/Users/uri/Documents/GitHub/echo/prototype/src/services/DataCollectionService.js"],"sourcesContent":["// Data Collection and Integration Service\nimport { saveAssessmentResult, saveInterventionUsage, saveProgressEntry } from '../components/firestoreHelpers';\nimport authService from './AuthService';\n\nclass DataCollectionService {\n    constructor() {\n        this.dataStore = {\n            assessments: [],\n            biometrics: [],\n            interventions: [],\n            userProfile: {},\n            preferences: {}\n        };\n        this.initialized = false;\n    }\n\n    // Initialize the service\n    async initialize() {\n        try {\n            // Initialize auth service first\n            authService.initialize();\n            \n            // Load existing data from localStorage\n            const storedData = localStorage.getItem('echoMentalHealthData');\n            if (storedData) {\n                this.dataStore = { ...this.dataStore, ...JSON.parse(storedData) };\n            }\n            \n            // Initialize wearable connections\n            await this.initializeWearableConnections();\n            \n            this.initialized = true;\n            console.log('✅ Data Collection Service initialized');\n        } catch (error) {\n            console.error('❌ Failed to initialize Data Collection Service:', error);\n        }\n    }\n\n    // Save assessment data\n    saveAssessment(assessmentData) {\n        const assessment = {\n            id: Date.now().toString(),\n            timestamp: new Date().toISOString(),\n            type: 'mental_health_assessment',\n            data: assessmentData,\n            source: 'app_questionnaire'\n        };\n\n        this.dataStore.assessments.push(assessment);\n        this.persistData();\n        \n        // Trigger analytics update\n        this.analyzePatterns();\n        \n        return assessment.id;\n    }\n\n    // Save biometric data\n    saveBiometricData(data, source = 'manual') {\n        const biometricEntry = {\n            id: Date.now().toString(),\n            timestamp: new Date().toISOString(),\n            data: data,\n            source: source, // 'camera', 'wearable', 'manual', etc.\n        };\n\n        this.dataStore.biometrics.push(biometricEntry);\n        this.persistData();\n        \n        return biometricEntry.id;\n    }\n\n    // Save intervention usage\n    saveInterventionUsage(interventionType, duration, effectiveness) {\n        const intervention = {\n            id: Date.now().toString(),\n            timestamp: new Date().toISOString(),\n            type: interventionType,\n            duration: duration,\n            effectiveness: effectiveness, // 1-5 scale\n            context: this.getCurrentContext()\n        };\n\n        this.dataStore.interventions.push(intervention);\n        this.persistData();\n        \n        return intervention.id;\n    }\n\n    // Camera-based emotion detection\n    async analyzeFacialExpressions(videoElement) {\n        try {\n            // This would integrate with TensorFlow.js or similar\n            // For now, returning mock data\n            const mockEmotionData = {\n                emotions: {\n                    happiness: Math.random() * 0.4,\n                    sadness: Math.random() * 0.3,\n                    anxiety: Math.random() * 0.4,\n                    stress: Math.random() * 0.3,\n                    neutral: Math.random() * 0.5,\n                    anger: Math.random() * 0.2,\n                    fear: Math.random() * 0.2\n                },\n                microExpressions: {\n                    eyeMovement: Math.random() * 100,\n                    blinkRate: Math.random() * 20 + 15,\n                    facialTension: Math.random() * 100,\n                    jawTension: Math.random() * 100\n                },\n                faceMetrics: {\n                    symmetry: Math.random() * 100,\n                    skinTone: Math.random() * 100,\n                    eyeBags: Math.random() * 100\n                },\n                confidence: 0.75 + Math.random() * 0.2,\n                processingTime: Math.random() * 500 + 200\n            };\n\n            this.saveBiometricData(mockEmotionData, 'camera');\n            return mockEmotionData;\n        } catch (error) {\n            console.error('Facial expression analysis failed:', error);\n            return null;\n        }\n    }\n\n    // Heart rate detection through camera\n    async detectHeartRateFromCamera(videoElement) {\n        try {\n            // This would use photoplethysmography (PPG) through camera\n            // Analyzing color changes in face/fingertip\n            const mockHeartRateData = {\n                heartRate: Math.floor(Math.random() * 40) + 60, // 60-100 bpm\n                heartRateVariability: Math.random() * 50 + 25,\n                confidence: 0.7 + Math.random() * 0.25,\n                signalQuality: Math.random() * 100,\n                timestamp: new Date().toISOString()\n            };\n\n            this.saveBiometricData(mockHeartRateData, 'camera_ppg');\n            return mockHeartRateData;\n        } catch (error) {\n            console.error('Heart rate detection failed:', error);\n            return null;\n        }\n    }\n\n    // Initialize wearable device connections\n    async initializeWearableConnections() {\n        try {\n            // Check for Web Bluetooth support\n            if ('bluetooth' in navigator) {\n                console.log('Bluetooth API available');\n                // Future implementation for fitness trackers, smartwatches\n            }\n\n            // Check for Web USB support\n            if ('usb' in navigator) {\n                console.log('USB API available');\n                // Future implementation for USB-connected devices\n            }\n\n            // Initialize mock wearable data\n            this.startMockWearableDataCollection();\n        } catch (error) {\n            console.error('Wearable initialization error:', error);\n        }\n    }\n\n    // Mock wearable data collection (for demonstration)\n    startMockWearableDataCollection() {\n        // Simulate periodic data from a fitness tracker\n        setInterval(() => {\n            if (Math.random() > 0.8) { // 20% chance every interval\n                const wearableData = {\n                    heartRate: Math.floor(Math.random() * 40) + 60,\n                    steps: Math.floor(Math.random() * 1000),\n                    sleepQuality: Math.random() * 100,\n                    stressLevel: Math.random() * 100,\n                    skinTemperature: 36 + Math.random() * 2,\n                    oxygenSaturation: 95 + Math.random() * 5\n                };\n                \n                this.saveBiometricData(wearableData, 'wearable_mock');\n            }\n        }, 30000); // Every 30 seconds\n    }\n\n    // Analyze patterns in collected data\n    analyzePatterns() {\n        try {\n            const recentData = this.getRecentData(7); // Last 7 days\n            \n            const patterns = {\n                moodTrends: this.analyzeMoodTrends(recentData.assessments),\n                biometricPatterns: this.analyzeBiometricPatterns(recentData.biometrics),\n                interventionEffectiveness: this.analyzeInterventionEffectiveness(recentData.interventions),\n                riskFactors: this.identifyRiskFactors(recentData),\n                recommendations: this.generateRecommendations(recentData)\n            };\n\n            // Store analysis results\n            this.dataStore.latestAnalysis = {\n                timestamp: new Date().toISOString(),\n                patterns: patterns\n            };\n\n            this.persistData();\n            return patterns;\n        } catch (error) {\n            console.error('Pattern analysis failed:', error);\n            return null;\n        }\n    }\n\n    // Get recent data within specified days\n    getRecentData(days) {\n        const cutoffDate = new Date();\n        cutoffDate.setDate(cutoffDate.getDate() - days);\n\n        return {\n            assessments: this.dataStore.assessments.filter(\n                item => new Date(item.timestamp) > cutoffDate\n            ),\n            biometrics: this.dataStore.biometrics.filter(\n                item => new Date(item.timestamp) > cutoffDate\n            ),\n            interventions: this.dataStore.interventions.filter(\n                item => new Date(item.timestamp) > cutoffDate\n            )\n        };\n    }\n\n    // Analyze mood trends\n    analyzeMoodTrends(assessments) {\n        if (assessments.length < 2) return { trend: 'insufficient_data' };\n\n        const moodScores = assessments\n            .map(a => a.data.overallScore)\n            .filter(score => score !== undefined);\n\n        if (moodScores.length < 2) return { trend: 'insufficient_data' };\n\n        const firstHalf = moodScores.slice(0, Math.ceil(moodScores.length / 2));\n        const secondHalf = moodScores.slice(Math.floor(moodScores.length / 2));\n\n        const firstAvg = firstHalf.reduce((sum, score) => sum + score, 0) / firstHalf.length;\n        const secondAvg = secondHalf.reduce((sum, score) => sum + score, 0) / secondHalf.length;\n\n        const difference = secondAvg - firstAvg;\n\n        return {\n            trend: difference > 0.2 ? 'improving' : difference < -0.2 ? 'declining' : 'stable',\n            change: difference,\n            currentAverage: secondAvg,\n            confidence: Math.min(moodScores.length / 10, 1) // More data = higher confidence\n        };\n    }\n\n    // Analyze biometric patterns\n    analyzeBiometricPatterns(biometrics) {\n        const heartRateData = biometrics\n            .filter(b => b.data.heartRate)\n            .map(b => b.data.heartRate);\n\n        const stressData = biometrics\n            .filter(b => b.data.stressLevel)\n            .map(b => b.data.stressLevel);\n\n        return {\n            heartRate: {\n                average: heartRateData.length > 0 ? \n                    heartRateData.reduce((sum, hr) => sum + hr, 0) / heartRateData.length : null,\n                trend: this.calculateTrend(heartRateData),\n                variability: this.calculateVariability(heartRateData)\n            },\n            stress: {\n                average: stressData.length > 0 ? \n                    stressData.reduce((sum, s) => sum + s, 0) / stressData.length : null,\n                trend: this.calculateTrend(stressData)\n            }\n        };\n    }\n\n    // Analyze intervention effectiveness\n    analyzeInterventionEffectiveness(interventions) {\n        const effectiveness = {};\n        \n        interventions.forEach(intervention => {\n            if (!effectiveness[intervention.type]) {\n                effectiveness[intervention.type] = {\n                    uses: 0,\n                    totalEffectiveness: 0,\n                    avgDuration: 0,\n                    totalDuration: 0\n                };\n            }\n            \n            effectiveness[intervention.type].uses++;\n            effectiveness[intervention.type].totalEffectiveness += intervention.effectiveness || 3;\n            effectiveness[intervention.type].totalDuration += intervention.duration || 300;\n        });\n\n        // Calculate averages\n        Object.keys(effectiveness).forEach(type => {\n            const data = effectiveness[type];\n            data.avgEffectiveness = data.totalEffectiveness / data.uses;\n            data.avgDuration = data.totalDuration / data.uses;\n        });\n\n        return effectiveness;\n    }\n\n    // Identify risk factors\n    identifyRiskFactors(data) {\n        const risks = [];\n\n        // Check mood trends\n        const moodTrend = this.analyzeMoodTrends(data.assessments);\n        if (moodTrend.trend === 'declining') {\n            risks.push({\n                type: 'declining_mood',\n                severity: Math.abs(moodTrend.change) > 0.5 ? 'high' : 'medium',\n                description: 'Estado de ánimo en declive'\n            });\n        }\n\n        // Check biometric patterns\n        const biometrics = this.analyzeBiometricPatterns(data.biometrics);\n        if (biometrics.heartRate.average > 90) {\n            risks.push({\n                type: 'elevated_heart_rate',\n                severity: 'medium',\n                description: 'Frecuencia cardíaca elevada promedio'\n            });\n        }\n\n        // Check intervention usage\n        if (data.interventions.length < 3) {\n            risks.push({\n                type: 'low_engagement',\n                severity: 'low',\n                description: 'Bajo uso de técnicas de calma'\n            });\n        }\n\n        return risks;\n    }\n\n    // Generate personalized recommendations\n    generateRecommendations(data) {\n        const recommendations = [];\n\n        // Based on mood trends\n        const moodTrend = this.analyzeMoodTrends(data.assessments);\n        if (moodTrend.trend === 'declining') {\n            recommendations.push({\n                type: 'intervention',\n                priority: 'high',\n                message: 'Considera aumentar el uso de técnicas de respiración y afirmaciones positivas'\n            });\n        }\n\n        // Based on intervention effectiveness\n        const effectiveness = this.analyzeInterventionEffectiveness(data.interventions);\n        const mostEffective = Object.entries(effectiveness)\n            .sort((a, b) => b[1].avgEffectiveness - a[1].avgEffectiveness)[0];\n\n        if (mostEffective) {\n            recommendations.push({\n                type: 'technique',\n                priority: 'medium',\n                message: `La técnica \"${mostEffective[0]}\" ha sido más efectiva para ti`\n            });\n        }\n\n        // General wellness recommendations\n        recommendations.push({\n            type: 'general',\n            priority: 'low',\n            message: 'Mantén un horario regular para tus evaluaciones de bienestar'\n        });\n\n        return recommendations;\n    }\n\n    // Utility functions\n    calculateTrend(values) {\n        if (values.length < 2) return 'insufficient_data';\n        \n        const firstHalf = values.slice(0, Math.ceil(values.length / 2));\n        const secondHalf = values.slice(Math.floor(values.length / 2));\n        \n        const firstAvg = firstHalf.reduce((sum, val) => sum + val, 0) / firstHalf.length;\n        const secondAvg = secondHalf.reduce((sum, val) => sum + val, 0) / secondHalf.length;\n        \n        const difference = secondAvg - firstAvg;\n        return difference > 5 ? 'increasing' : difference < -5 ? 'decreasing' : 'stable';\n    }\n\n    calculateVariability(values) {\n        if (values.length < 2) return 0;\n        \n        const mean = values.reduce((sum, val) => sum + val, 0) / values.length;\n        const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;\n        return Math.sqrt(variance);\n    }\n\n    getCurrentContext() {\n        return {\n            timeOfDay: new Date().getHours(),\n            dayOfWeek: new Date().getDay(),\n            location: 'unknown', // Would integrate with geolocation\n            weather: 'unknown'   // Would integrate with weather API\n        };\n    }\n\n    // Data persistence\n    persistData() {\n        try {\n            localStorage.setItem('echoMentalHealthData', JSON.stringify(this.dataStore));\n        } catch (error) {\n            console.error('Failed to persist data:', error);\n        }\n    }\n\n    // Export data for analysis or backup\n    exportData() {\n        return {\n            exportDate: new Date().toISOString(),\n            version: '1.0',\n            data: this.dataStore\n        };\n    }\n\n    // Clear all data (with confirmation)\n    clearAllData() {\n        this.dataStore = {\n            assessments: [],\n            biometrics: [],\n            interventions: [],\n            userProfile: {},\n            preferences: {}\n        };\n        localStorage.removeItem('echoMentalHealthData');\n    }\n\n    // Get comprehensive analytics\n    getAnalytics(timeRange = 30) {\n        const recentData = this.getRecentData(timeRange);\n        return {\n            summary: {\n                totalAssessments: recentData.assessments.length,\n                totalInterventions: recentData.interventions.length,\n                averageMoodScore: this.calculateAverageScore(recentData.assessments),\n                timeRange: timeRange\n            },\n            patterns: this.analyzePatterns(),\n            riskFactors: this.identifyRiskFactors(recentData),\n            recommendations: this.generateRecommendations(recentData)\n        };\n    }\n\n    calculateAverageScore(assessments) {\n        if (assessments.length === 0) return null;\n        \n        const scores = assessments\n            .map(a => a.data.overallScore)\n            .filter(score => score !== undefined);\n            \n        return scores.length > 0 ? \n            scores.reduce((sum, score) => sum + score, 0) / scores.length : null;\n    }\n}\n\n// Create singleton instance\nconst dataCollectionService = new DataCollectionService();\n\nexport default dataCollectionService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}